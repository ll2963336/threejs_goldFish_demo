<!DOCTYPE html>
<html lang="en">
  <head>
    <title>GOLDFISH</title>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"
      id="viewport"
      name="viewport"
    />
    <link rel="stylesheet" href="./assets/css/common.css" type="text/css" />
  </head>
  <body style="margin: 0; overflow: hidden">
    <!-- three相關 -->
    <div id="three" style="position: relative; z-index: 100">
      <button
        id="start_demo"
        style="
          height: 40px;
          width: 5rem;
          border-radius: 0.5rem;
          text-align: center;
          background: rgba(0, 0, 0, 0.3);
          position: absolute;
          color: white;
          bottom: 5%;
          left: 50%;
          transform: translateX(-50%);
        "
      >
        開始
      </button>
    </div>
    <!-- 得分、座標顯示相關 -->
    <div
      style="
        box-sizing: border-box;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        right: 0;
        background: transparent;
        color: white;
        display: flex;
        justify-content: space-between;
        padding: 0 0.2rem;
        border: rgba(128, 128, 128, 0.236) 0.5rem solid;
      "
    >
      <div
        style="
          background: transparent;
          display: flex;
          flex-direction: column;
          justify-items: flex-start;
        "
      >
        <div id="demo_x"></div>
        <div id="demo_z"></div>
        <div id="demo_cube_x"></div>
        <div id="demo_cube_z"></div>
        <div id="countdown"></div>
        <div id="time"></div>
      </div>
      <div
        style="
          position: absolute;
          width: 100px;
          height: 100px;
          top: 50%;
          left: 50%;
          background: rgba(128, 128, 128, 0.236);
          transform: translate(-50%, -50%);
        "
      ></div>

      <div style="display: flex; flex-direction: column; align-items: flex-end">
        <div>
          <label for="lose_score">l: </label>
          <input
            disabled
            class="input_score"
            type="number"
            name="lose_score"
            id="lose_score"
          />
        </div>
        <div>
          <label for="win_score">w: </label>
          <input
            disabled
            class="input_score"
            type="number"
            name="win_score"
            id="win_score"
          />
        </div>
      </div>
    </div>
    <!-- 相機背景相關 -->
    <video
      style="
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        z-index: -100;
      "
    />

    <script src="./assets/js/camera.js"></script>
    <script src="./assets/js/common.js"></script>

    <script>
      document.addEventListener(
        "touchmove",
        function (event) {
          if (event.scale !== 1) {
            event.preventDefault();
          }
        },
        { passive: false }
      );
    </script>

    <script
      async
      src="https://cdn.jsdelivr.net/npm/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.143.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import Stats from "./assets/js/stats.module.js";

      import { FBXLoader } from "https://cdn.jsdelivr.net/npm/three@0.143.0/examples/jsm/loaders/FBXLoader.js";
      import { GLTFLoader } from "./assets/js/GLTFLoader.js";
      // import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.143.0/examples/jsm/controls/OrbitControls.js";
      // import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.143.0/examples/jsm/loaders/GLTFLoader.js";
      // import { FBXLoader } from "./assets/js/FBXLoader.js";

      let camera, scene, renderer, stats;

      let mixer;

      const BOX_WIDTH = 10;
      const HALF_WINDOW_WIDTH = window.innerWidth / 2;
      const HALF_WINDOW_HEIGHT = window.innerHeight / 2;
      const WINDOW_ASPECT = window.innerWidth / window.innerHeight;

      const random_point = [
        [-HALF_WINDOW_WIDTH + 20, 0],
        [0, -HALF_WINDOW_HEIGHT + 20],
        [HALF_WINDOW_WIDTH - 20, 0],
      ];

      let x = 0;
      let z = 0;
      let px = 0;
      let pz = 0;
      let speed_percent = 1 / 10;

      let random_num = randomIntFromInterval(0, 2);
      px = random_point[random_num][0];
      pz = random_point[random_num][1];

      let win_score = 0;
      let lose_score = 0;

      let time = null;
      let countdown = 3;

      const clock = new THREE.Clock();

      const container = document.getElementById("three");
      const win_score_container = document.getElementById("win_score");
      const lose_score_container = document.getElementById("lose_score");

      win_score_container.value = win_score;
      lose_score_container.value = lose_score;

      camera = new THREE.OrthographicCamera(
        -HALF_WINDOW_WIDTH,
        HALF_WINDOW_WIDTH,
        HALF_WINDOW_HEIGHT,
        -HALF_WINDOW_HEIGHT,
        1,
        2000
      );

      camera.position.set(0, 500, 0);
      camera.rotation.x = -0.5 * Math.PI;

      scene = new THREE.Scene();
      scene.background = null;
      // scene.background = new THREE.Color(0xa0a0a0);
      // scene.fog = new THREE.Fog(0xa0a0a0, 200, 1000);

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
      hemiLight.position.set(0, 2000, 0);
      scene.add(hemiLight);

      // cube
      // const geometry = new THREE.BoxGeometry(BOX_WIDTH, BOX_WIDTH, BOX_WIDTH);
      // const material = new THREE.MeshBasicMaterial({ color: 0x999000 });
      // const cube = new THREE.Mesh(geometry, material);
      // cube.position.set(0, 5, 0);
      // scene.add(cube);

      // cube border
      // const edges = new THREE.EdgesGeometry(geometry);
      // const line = new THREE.LineSegments(
      //   edges,
      //   new THREE.LineBasicMaterial({ color: 0x000000 })
      // );
      // line.position.set(0, 5, 0);
      // scene.add(line);

      const dirLight = new THREE.DirectionalLight(0xffffff);
      dirLight.position.set(0, 2000, 200);
      dirLight.castShadow = true;
      dirLight.shadow.camera.top = 180;
      dirLight.shadow.camera.bottom = -100;
      dirLight.shadow.camera.left = -120;
      dirLight.shadow.camera.right = 120;
      scene.add(dirLight);
      scene.add(new THREE.CameraHelper(dirLight.shadow.camera));

      // ground
      // const mesh = new THREE.Mesh(
      //   new THREE.PlaneGeometry(2000, 2000),
      //   new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false })
      // );
      // mesh.rotation.x = -Math.PI / 2;
      // mesh.receiveShadow = true;
      // scene.add(mesh);

      // grid
      // const grid = new THREE.GridHelper(1000, 20, 0x000000, 0x000000);
      // grid.material.opacity = 0.1;
      // grid.material.transparent = true;
      // scene.add(grid);

      // load gltf
      const loader = new GLTFLoader();
      let gltfModel = null;
      loader.load("./assets/fish/fish.glb", function (gltf) {
        gltfModel = gltf.scene;
        console.log(gltfModel);
        gltfModel.position.x = 100;
        gltfModel.scale.set(25, 25, 25);
        gltfModel.rotation.x = -0.25 * Math.PI;

        mixer = new THREE.AnimationMixer(gltf.scene);
        const action = mixer.clipAction(gltf.animations[7]);
        action.play();

        scene.add(gltfModel);
      });

      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      // const controls = new OrbitControls(camera, renderer.domElement);
      // controls.target.set(0, 100, 0);
      // controls.update();

      window.addEventListener("resize", onWindowResize);

      // stats
      // stats = new Stats();
      // container.appendChild(stats.dom);

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // model移動相關
      const actionElement = document.getElementById("start_demo");
      actionElement.onclick = function () {
        if (
          DeviceMotionEvent &&
          typeof DeviceMotionEvent.requestPermission === "function"
        ) {
          DeviceMotionEvent.requestPermission();
          actionElement.setAttribute("disable", true);
          actionElement.innerText = "重力感應";
        }
        window.addEventListener("deviceorientation", (event) => {
          // Expose each orientation angle in a more readable way
          if (event?.gamma) {
            z = Number(event?.beta.toFixed(1)) * speed_percent * 3;
          }
          if (event?.beta) {
            x = Number(event?.gamma.toFixed(1)) * speed_percent;
          }
          document.getElementById("demo_x").innerHTML = `x = ${x.toFixed(1)}`;
          document.getElementById("demo_z").innerHTML = `z = ${z.toFixed(1)}`;
          document.getElementById(
            "demo_cube_x"
          ).innerHTML = `px=${gltfModel.position.x.toFixed(2)}`;
          document.getElementById(
            "demo_cube_z"
          ).innerHTML = `pz=${gltfModel.position.z.toFixed(2)}`;
          document.getElementById("countdown").innerHTML = `cd=${countdown}`;
          document.getElementById("time").innerHTML = `time=${time}`;
        });
      };
      function move() {
        if (
          px < HALF_WINDOW_WIDTH - BOX_WIDTH &&
          px > -HALF_WINDOW_WIDTH + BOX_WIDTH
        ) {
          if (px + x >= HALF_WINDOW_WIDTH - BOX_WIDTH) {
            px = HALF_WINDOW_WIDTH - BOX_WIDTH - 1;
          } else if (px + x <= -HALF_WINDOW_WIDTH + BOX_WIDTH) {
            px = -HALF_WINDOW_WIDTH + BOX_WIDTH + 1;
          } else {
            px += x;
          }
        }

        if (pz < HALF_WINDOW_HEIGHT && pz > -HALF_WINDOW_HEIGHT) {
          if (pz + z >= HALF_WINDOW_HEIGHT) {
            pz = HALF_WINDOW_HEIGHT - 1;
          } else if (pz + z <= -HALF_WINDOW_HEIGHT) {
            pz = -HALF_WINDOW_HEIGHT + 1;
          } else {
            pz += z;
          }
        }
        // cube.position.x = px;
        // line.position.x = px;
        // cube.position.z = pz;
        // line.position.z = pz;
        gltfModel.position.x = px;
        gltfModel.position.z = pz;
      }

      // debounce
      function Countdown() {
        time = setInterval(() => {
          actionElement.innerText = `捕捉中...${countdown--}`;
        }, 1000);
      }

      function ClearCountdown() {
        if (time) {
          actionElement.innerText = `重力感應`;
          clearInterval(time);
          time = null;
        }
      }

      function getWinGoal() {
        if (px < 50 && px > -50 && pz < 50 && pz > -50) {
          if (!time) {
            Countdown();
          }
          if (countdown === -1) {
            actionElement.innerText = `重力感應`;
            win_score_container.value = ++win_score;
            clearInterval(time);
            countdown = 3;
            time = null;
          }
        } else {
          ClearCountdown();
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        move();
        getWinGoal();
        const delta = clock.getDelta();
        if (mixer) mixer.update(delta);
        renderer.render(scene, camera);
        // stats.update();
      }

      animate();
    </script>
  </body>
</html>
